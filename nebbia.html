<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nebbia che invade – WebGL</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background:#000; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      width: min(390px, calc(100vw - 24px));
      background: rgba(10, 12, 18, 0.58);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 12px 12px 10px;
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.9);
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    #ui h1 { margin: 0 0 6px; font-size: 14px; font-weight: 650; letter-spacing: 0.2px; }
    #ui .sub { margin: 0 0 10px; font-size: 11px; color: rgba(255,255,255,0.70); line-height:1.35; }
    .row { display:flex; gap:10px; align-items:center; margin: 8px 0; }
    .row label { flex: 1; font-size: 12px; color: rgba(255,255,255,0.78); }
    .row input[type="range"] { flex: 1.6; }
    .row output { width: 64px; text-align:right; font-size: 12px; color: rgba(255,255,255,0.85); }
    .row .toggle { flex: 1.6; display:flex; justify-content:flex-end; }
    .row input[type="checkbox"]{ transform: scale(1.1); }
    button {
      width: 100%;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.92);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 650;
      cursor: pointer;
    }
    button:hover { background: rgba(255,255,255,0.12); }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
    .note { margin-top: 8px; font-size: 11px; color: rgba(255,255,255,0.62); line-height: 1.35; }
    #hint {
      position: fixed; right: 12px; bottom: 12px; z-index: 10;
      background: rgba(10, 12, 18, 0.35);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 12px;
      color: rgba(255,255,255,0.80);
      font-size: 12px;
      backdrop-filter: blur(10px);
      user-select: none;
    }
    #diag {
      position: fixed; left: 12px; bottom: 12px; z-index: 10;
      width: min(520px, calc(100vw - 24px));
      background: rgba(10, 12, 18, 0.42);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 12px;
      color: rgba(255,255,255,0.78);
      font-size: 12px;
      backdrop-filter: blur(10px);
      display:none;
      white-space: pre-wrap;
    }
  </style>

  <!--
    FIX IMPORTS:
    L'errore "Module name 'three' does not resolve" avviene quando OrbitControls (e altri addons)
    importano "three" come bare specifier. Qui lo risolviamo con importmap + addons path.
  -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="ui">
    <h1>Nebbia che invade (in avanti) – WebGL</h1>
    <p class="sub">Monte + crepuscolo + vette sullo sfondo. La nebbia avanza dal fondo valle verso di te. Tutto in un solo file HTML.</p>

    <div class="grid2">
      <button id="startBtn">Start esperimento</button>
      <button id="resetBtn">Reset</button>
    </div>

    <div class="row" style="margin-top:10px;">
      <label for="fogIntensity">Intensità nebbia</label>
      <input id="fogIntensity" type="range" min="0" max="1" step="0.01" value="0.0">
      <output id="fogVal">0%</output>
    </div>

    <div class="row">
      <label for="fogSpeed">Velocità invasione</label>
      <input id="fogSpeed" type="range" min="0" max="1" step="0.01" value="0.35">
      <output id="speedVal">35%</output>
    </div>

    <div class="row">
      <label for="fogDepth">Profondità banco</label>
      <input id="fogDepth" type="range" min="40" max="520" step="5" value="240">
      <output id="depthVal">240</output>
    </div>

    <div class="row">
      <label for="twilight">Crepuscolo (auto)</label>
      <div class="toggle"><input id="twilight" type="checkbox" checked></div>
      <output id="twVal">on</output>
    </div>

    <div class="row">
      <label for="twilightSpeed">Velocità crepuscolo</label>
      <input id="twilightSpeed" type="range" min="0" max="1" step="0.01" value="0.25">
      <output id="twSpVal">25%</output>
    </div>

    <div class="row">
      <label for="wind">Vento (foschia)</label>
      <input id="wind" type="range" min="0" max="1" step="0.01" value="0.35">
      <output id="windVal">35%</output>
    </div>

    <div class="row">
      <label for="sound">Suono (vento)</label>
      <div class="toggle"><input id="sound" type="checkbox"></div>
      <output id="sndVal">off</output>
    </div>

    <div class="row">
      <label for="volume">Volume</label>
      <input id="volume" type="range" min="0" max="1" step="0.01" value="0.25">
      <output id="volVal">25%</output>
    </div>

    <div class="row">
      <label for="view">FOV (zoom)</label>
      <input id="view" type="range" min="35" max="80" step="1" value="55">
      <output id="viewVal">55°</output>
    </div>

    <div class="note">
      Drag = guarda • Wheel = zoom • <b>Start</b> avvia l’invasione + il crepuscolo. Slider = controllo manuale.
    </div>
  </div>

  <div id="hint">Drag = guarda • Wheel = zoom</div>
  <div id="diag"></div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // -------------------- Mini test suite (runtime) --------------------
    // Non è un progetto Node: qui i “test” sono check runtime leggibili.
    const diag = document.getElementById('diag');
    function showDiag(msg){ diag.style.display = 'block'; diag.textContent = msg; }

    function test(name, fn){
      try { fn(); return { name, ok:true }; }
      catch (e){ return { name, ok:false, err: e }; }
    }

    const tests = [];
    tests.push(test('Import THREE disponibile', () => {
      if (!THREE || !THREE.Scene) throw new Error('THREE non caricato');
    }));
    tests.push(test('WebGL supportato', () => {
      const c = document.createElement('canvas');
      const gl = c.getContext('webgl') || c.getContext('experimental-webgl');
      if (!gl) throw new Error('WebGL non disponibile (driver/browser)');
    }));
    tests.push(test('OrbitControls disponibile', () => {
      if (typeof OrbitControls !== 'function') throw new Error('OrbitControls non caricato');
    }));

    const failed = tests.filter(t => !t.ok);
    if (failed.length){
      const lines = failed.map(f => `✗ ${f.name}: ${String(f.err && f.err.message || f.err)}`);
      showDiag('Errore avvio simulazione.\n\n' + lines.join('\n') + '\n\nSuggerimento: apri via HTTP/HTTPS (GitHub Pages) e non da file://.');
      throw failed[0].err;
    }

    // -------------------- Utils --------------------
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const lerp = (a,b,t) => a + (b-a)*t;

    // rumore 2D semplice (value noise) per montagne procedurali
    function hash2(x, y){
      let n = x * 374761393 + y * 668265263;
      n = (n ^ (n >> 13)) * 1274126177;
      return ((n ^ (n >> 16)) >>> 0) / 4294967295;
    }
    function smooth(t){ return t*t*(3-2*t); }
    function noise2(x, y){
      const xi = Math.floor(x), yi = Math.floor(y);
      const xf = x - xi, yf = y - yi;
      const v00 = hash2(xi, yi);
      const v10 = hash2(xi+1, yi);
      const v01 = hash2(xi, yi+1);
      const v11 = hash2(xi+1, yi+1);
      const u = smooth(xf), v = smooth(yf);
      const a = lerp(v00, v10, u);
      const b = lerp(v01, v11, u);
      return lerp(a, b, v);
    }
    function fbm(x, y){
      let sum = 0, amp = 0.55, freq = 0.9;
      for(let i=0;i<5;i++){
        sum += amp * noise2(x*freq, y*freq);
        amp *= 0.5;
        freq *= 2.0;
      }
      return sum;
    }

    // -------------------- Renderer / Scene --------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    // -------------------- Camera / Controls --------------------
    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1400);
    camera.position.set(0, 28, 115);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.target.set(0, 18, 0);
    controls.minDistance = 55;
    controls.maxDistance = 240;
    controls.maxPolarAngle = Math.PI * 0.49;

    // -------------------- Palette crepuscolo --------------------
    const fogBase = new THREE.Color("#6b7ea6");
    const fogCold = new THREE.Color("#9db2c7");

    // Fog globale (leggero): il grosso effetto d'invasione lo fa un "banco" in avanti
    scene.fog = new THREE.Fog(fogBase.clone(), 35, 620);

    // -------------------- Sky (shader) con crepuscolo animabile --------------------
    const skyGeo = new THREE.SphereGeometry(900, 56, 36);
    const skyMat = new THREE.ShaderMaterial({
      side: THREE.BackSide,
      uniforms: {
        topColor: { value: new THREE.Color("#070a14") },
        midColor: { value: new THREE.Color("#1d2745") },
        horiColor:{ value: new THREE.Color("#bf7c55") },
        fogColor: { value: fogBase.clone() },
        t: { value: 0.0 },
      },
      vertexShader: `
        varying vec3 vPos;
        void main(){
          vPos = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 topColor;
        uniform vec3 midColor;
        uniform vec3 horiColor;
        uniform vec3 fogColor;
        uniform float t;
        varying vec3 vPos;

        float softBand(float x, float center, float width){
          float d = abs(x - center);
          return 1.0 - smoothstep(0.0, width, d);
        }

        void main(){
          float y = normalize(vPos).y;
          float u = (y + 1.0) * 0.5;

          vec3 hc = mix(horiColor, vec3(0.25, 0.28, 0.38), t);
          vec3 mc = mix(midColor, vec3(0.07, 0.09, 0.16), t);
          vec3 tc = mix(topColor, vec3(0.02, 0.02, 0.04), t);

          vec3 col = mix(hc, mc, smoothstep(0.05, 0.55, u));
          col = mix(col, tc, smoothstep(0.55, 1.0, u));

          float band = softBand(u, 0.18, 0.12);
          col += band * mix(vec3(0.18, 0.10, 0.05), vec3(0.03,0.03,0.04), t);

          col = mix(col, fogColor, 0.10);
          gl_FragColor = vec4(col, 1.0);
        }
      `
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // -------------------- Lighting --------------------
    const dir = new THREE.DirectionalLight("#d6dbe8", 0.85);
    dir.position.set(-120, 90, 40);
    scene.add(dir);

    const fill = new THREE.HemisphereLight("#6d7aa8", "#141820", 0.9);
    scene.add(fill);

    // -------------------- Ground --------------------
    const groundGeo = new THREE.PlaneGeometry(1400, 1400, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({ color: new THREE.Color("#10131a"), roughness: 1.0, metalness: 0.0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    // -------------------- Mountain ridges --------------------
    function makeRidge({ z, scaleX, height, seed, color, opacity }) {
      const w = 980;
      const h = 240;
      const segX = 260;
      const segY = 52;
      const geo = new THREE.PlaneGeometry(w, h, segX, segY);
      const pos = geo.attributes.position;

      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const nx = (x / (w*0.5));
        const profile = Math.pow(1.0 - Math.abs(nx), 0.45);
        const n = fbm((x*0.008) + seed, (y*0.02) + seed);
        const jag = (n - 0.5) * 2.0;

        let yy = y;
        if (y > -h*0.38) {
          yy += profile * height * (0.55 + 0.45*n) + jag * height * 0.18;
        } else {
          yy += jag * height * 0.05;
        }
        pos.setY(i, yy);
      }

      geo.computeVertexNormals();

      const mat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(color),
        roughness: 1.0,
        metalness: 0.0,
        transparent: true,
        opacity,
        fog: true
      });

      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(0, 30, z);
      mesh.scale.x = scaleX;
      return mesh;
    }

    const ridges = [];
    ridges.push(makeRidge({ z: -70,  scaleX: 1.00, height: 90,  seed: 10.2, color: "#1b2232", opacity: 1.0 }));
    ridges.push(makeRidge({ z: -160, scaleX: 1.07, height: 125, seed: 22.7, color: "#151c2b", opacity: 0.98 }));
    ridges.push(makeRidge({ z: -250, scaleX: 1.15, height: 155, seed: 35.4, color: "#121828", opacity: 0.94 }));
    ridges.push(makeRidge({ z: -360, scaleX: 1.28, height: 190, seed: 48.9, color: "#0f1422", opacity: 0.90 }));
    ridges.forEach(r => scene.add(r));

    // -------------------- Haze (foschia) - shader con vento --------------------
    const hazeGeo = new THREE.PlaneGeometry(980, 360, 1, 1);
    const hazeMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      uniforms: {
        fogColor: { value: fogBase.clone() },
        density: { value: 0.0 },
        wind: { value: 0.0 },
        time: { value: 0.0 },
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 fogColor;
        uniform float density;
        uniform float wind;
        uniform float time;
        varying vec2 vUv;

        float rand(vec2 co){
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        float smoothNoise(vec2 uv){
          vec2 i = floor(uv);
          vec2 f = fract(uv);
          float a = rand(i);
          float b = rand(i + vec2(1.0, 0.0));
          float c = rand(i + vec2(0.0, 1.0));
          float d = rand(i + vec2(1.0, 1.0));
          vec2 u = f*f*(3.0-2.0*f);
          return mix(a, b, u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
        }

        void main(){
          float h = smoothstep(0.0, 0.90, 1.0 - vUv.y);

          vec2 uv = vUv;
          uv.x += time * (0.04 + 0.20*wind);
          uv.y += time * (0.01 + 0.06*wind);

          float n = 0.0;
          n += 0.60 * smoothNoise(uv * 6.0);
          n += 0.25 * smoothNoise(uv * 14.0);
          n += 0.15 * smoothNoise(uv * 28.0);

          float grain = (n - 0.5) * (0.10 + 0.22*wind);

          float a = density * (0.62*h + 0.20) + grain;
          a = clamp(a, 0.0, 0.95);
          gl_FragColor = vec4(fogColor, a);
        }
      `
    });

    const haze = new THREE.Mesh(hazeGeo, hazeMat);
    haze.position.set(0, 55, -150);
    scene.add(haze);

    // -------------------- Fog bank (banco che invade in avanti) --------------------
    const bankGeo = new THREE.PlaneGeometry(1100, 520, 1, 1);
    const bankMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      uniforms: {
        fogColor: { value: fogBase.clone() },
        strength: { value: 0.0 },
        depth: { value: 240.0 },
        time: { value: 0.0 },
        wind: { value: 0.0 },
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 fogColor;
        uniform float strength;
        uniform float depth;
        uniform float time;
        uniform float wind;
        varying vec2 vUv;

        float rand(vec2 co){
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        float fbm2(vec2 p){
          float f = 0.0;
          float a = 0.55;
          for(int i=0;i<5;i++){
            f += a * rand(floor(p));
            p *= 2.0;
            a *= 0.5;
          }
          return f;
        }

        void main(){
          float edgeX = smoothstep(0.0, 0.10, vUv.x) * (1.0 - smoothstep(0.90, 1.0, vUv.x));
          float edgeY = smoothstep(0.0, 0.12, vUv.y) * (1.0 - smoothstep(0.86, 1.0, vUv.y));
          float mask = edgeX * edgeY;

          vec2 p = vUv * 10.0;
          p.x += time * (0.06 + 0.22*wind);
          p.y += time * (0.02 + 0.08*wind);
          float n = fbm2(p);

          float low = smoothstep(0.0, 0.85, 1.0 - vUv.y);

          float a = strength * (0.75*low + 0.18) * mask;
          a += (n - 0.5) * (0.08 + 0.14*wind) * strength;
          a = clamp(a, 0.0, 0.97);

          gl_FragColor = vec4(fogColor, a);
        }
      `
    });

    const fogBank = new THREE.Mesh(bankGeo, bankMat);
    fogBank.position.set(0, 60, -520);
    scene.add(fogBank);

    // -------------------- UI --------------------
    const startBtn = document.getElementById("startBtn");
    const resetBtn = document.getElementById("resetBtn");

    const fogIntensity = document.getElementById("fogIntensity");
    const fogVal = document.getElementById("fogVal");

    const fogSpeed = document.getElementById("fogSpeed");
    const speedVal = document.getElementById("speedVal");

    const fogDepth = document.getElementById("fogDepth");
    const depthVal = document.getElementById("depthVal");

    const twilight = document.getElementById("twilight");
    const twVal = document.getElementById("twVal");

    const twilightSpeed = document.getElementById("twilightSpeed");
    const twSpVal = document.getElementById("twSpVal");

    const wind = document.getElementById("wind");
    const windVal = document.getElementById("windVal");

    const sound = document.getElementById("sound");
    const sndVal = document.getElementById("sndVal");

    const volume = document.getElementById("volume");
    const volVal = document.getElementById("volVal");

    const view = document.getElementById("view");
    const viewVal = document.getElementById("viewVal");

    let running = false;

    function pct(x){ return `${Math.round(parseFloat(x)*100)}%`; }
    function updateLabels(){
      fogVal.textContent = pct(fogIntensity.value);
      speedVal.textContent = pct(fogSpeed.value);
      depthVal.textContent = `${fogDepth.value}`;
      twVal.textContent = twilight.checked ? "on" : "off";
      twSpVal.textContent = pct(twilightSpeed.value);
      windVal.textContent = pct(wind.value);
      sndVal.textContent = sound.checked ? "on" : "off";
      volVal.textContent = pct(volume.value);
      viewVal.textContent = `${view.value}°`;
    }
    updateLabels();

    view.addEventListener("input", () => {
      camera.fov = parseFloat(view.value);
      camera.updateProjectionMatrix();
      updateLabels();
    });

    [fogIntensity, fogSpeed, fogDepth, twilightSpeed, wind, volume].forEach(el => el.addEventListener("input", updateLabels));
    [twilight, sound].forEach(el => el.addEventListener("change", updateLabels));

    startBtn.addEventListener("click", async () => {
      running = !running;
      startBtn.textContent = running ? "Ferma esperimento" : "Start esperimento";
      if (sound.checked) {
        await ensureAudio();
        setAudioEnabled(true);
      }
    });

    resetBtn.addEventListener("click", () => {
      running = false;
      startBtn.textContent = "Start esperimento";
      fogIntensity.value = 0.0;
      fogSpeed.value = 0.35;
      fogDepth.value = 240;
      wind.value = 0.35;
      twilight.checked = true;
      twilightSpeed.value = 0.25;
      sound.checked = false;
      volume.value = 0.25;
      view.value = 55;
      camera.fov = 55;
      camera.updateProjectionMatrix();

      actualFog = 0.0;
      fogFront = 0.0;
      twilightT = 0.0;
      fogBank.position.z = -520;
      applyAtmosphere(0.0);

      setAudioEnabled(false);
      updateLabels();
    });

    // -------------------- Audio (vento leggero procedurale) --------------------
    let audioCtx = null;
    let noiseNode = null;
    let filterNode = null;
    let gainNode = null;
    let audioEnabled = false;

    async function ensureAudio(){
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const out = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) out[i] = Math.random() * 2 - 1;

      noiseNode = audioCtx.createBufferSource();
      noiseNode.buffer = noiseBuffer;
      noiseNode.loop = true;

      filterNode = audioCtx.createBiquadFilter();
      filterNode.type = "lowpass";
      filterNode.frequency.value = 420;
      filterNode.Q.value = 0.8;

      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0.0;

      noiseNode.connect(filterNode);
      filterNode.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      noiseNode.start();
    }

    function setAudioEnabled(on){
      audioEnabled = on;
      if (!gainNode) return;
      gainNode.gain.value = on ? parseFloat(volume.value) * 0.25 : 0.0;
    }

    sound.addEventListener("change", async () => {
      if (sound.checked) {
        await ensureAudio();
        setAudioEnabled(true);
      } else {
        setAudioEnabled(false);
      }
    });

    volume.addEventListener("input", () => {
      if (!gainNode) return;
      if (audioEnabled) gainNode.gain.value = parseFloat(volume.value) * 0.25;
    });

    // -------------------- Atmosphere dynamics --------------------
    let actualFog = 0.0;
    let fogFront = 0.0;
    let twilightT = 0.0;

    function applyAtmosphere(level){
      const w = clamp01(parseFloat(wind.value));

      const col = fogBase.clone().lerp(fogCold, level * 0.65);
      scene.fog.color.copy(col);
      skyMat.uniforms.fogColor.value.copy(col);
      hazeMat.uniforms.fogColor.value.copy(col);
      bankMat.uniforms.fogColor.value.copy(col);

      scene.fog.near = lerp(160, 45, level);
      scene.fog.far  = lerp(740, 260, level);

      hazeMat.uniforms.density.value = level;
      hazeMat.uniforms.wind.value = w;

      bankMat.uniforms.strength.value = level;
      bankMat.uniforms.depth.value = parseFloat(fogDepth.value);
      bankMat.uniforms.wind.value = w;

      for (let i=0;i<ridges.length;i++){
        const distFactor = i / (ridges.length - 1);
        const baseOp = 1.0 - distFactor*0.15;
        const fogged = (0.72 - distFactor*0.36);
        ridges[i].material.opacity = lerp(baseOp, fogged, level);
      }

      if (gainNode && audioEnabled) {
        const vv = parseFloat(volume.value) * 0.25;
        const wv = lerp(0.7, 1.35, w);
        const fv = lerp(0.85, 1.15, level);
        gainNode.gain.value = vv * wv * fv;
        filterNode.frequency.value = lerp(380, 520, w);
      }
    }

    // -------------------- Animate --------------------
    let last = performance.now();
    function animate(now){
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;

      const tSec = now * 0.001;
      const target = clamp01(parseFloat(fogIntensity.value));
      const spd = lerp(0.05, 0.85, clamp01(parseFloat(fogSpeed.value)));

      hazeMat.uniforms.time.value = tSec;
      bankMat.uniforms.time.value = tSec;

      if (running && twilight.checked) {
        const twSpd = lerp(0.01, 0.12, clamp01(parseFloat(twilightSpeed.value)));
        twilightT = clamp01(twilightT + dt * twSpd);
      }
      skyMat.uniforms.t.value = twilightT;

      if (running){
        actualFog = lerp(actualFog, target, 1.0 - Math.pow(1.0 - spd, dt*60));
        const maxFront = target;
        fogFront = lerp(fogFront, maxFront, 1.0 - Math.pow(1.0 - spd, dt*45));
      }

      const zStart = -520;
      const zEnd = -80;
      fogBank.position.z = lerp(zStart, zEnd, fogFront);
      fogBank.position.y = lerp(64, 56, actualFog);

      applyAtmosphere(actualFog);

      controls.update();
      renderer.render(scene, camera);
    }
    requestAnimationFrame(animate);

    applyAtmosphere(0.0);

    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
